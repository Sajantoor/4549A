angle_main_line = atan2f(delta_main_line.x, delta_main_line.y);			/*The angle of the line that we are following relative to the y-axis (the return value is in radians)*/

line_angle = nearestangle(angle_main_line - (max_speed < 0 ? pi : 0), orientation);			/*The direction between the start and end points of the path (the return value is in radians)*/

positionErr.x = position.x - ending_point_x;			/* The difference between our current position and our ending poisition or the target in the x-axis (The return value is in inches)*/
          
positionErr.y = position.y - ending_point_y;          	/* The difference between our current position and our ending poisition or the target in the y-axis (The return value is in inches)*/

vectorToPolar(positionErr, positionErrPolar);
positionErrPolar.theta += line_angle;
polarToVector(positionErrPolar, positionErr);

                                                                                                            

if (max_error)
{
err_angle = orientation - line_angle;                  			/* The difference between our current orientation and our "target orientation" (the return value is in radians)*/

err_x = positionErr.x + positionErr.y * tan(err_angle);			/* Calculation of how far off we will be if we continue on our current trajectory (The return value is in inches)*/

correctA = atan2(ending_point_x - position.x, ending_point_y - position.y);			/* Calculation of the direction to the target from our current position*/

if (max_speed < 0)                 					   			/* If the max speed is set to a negative number (less then 0)*/
correctA += pi;    						                        /* Add 180 degrees or pi (radians) to correctA*/

correction = fabs(err_x) > max_error ? 4.0 * (nearestangle(correctA, orientation) - orientation) * sgn(max_speed) : 0;    /* Calculation of the correction value but the correction value is only calculated if the bot is going to end up more off than we're allowed to be if our current trajectory continues*/

}
